package dev.prozilla.pine.core.entity;

import dev.prozilla.pine.core.component.Component;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * Represents a pool that creates and stores entity queries.
 * Each world has its own pool, because each world has different entities and components.
 * Certain entity queries are disposable, meaning the system that consumes them might dispose the results of that query.
 * Disposable queries cannot be included in the pool as their results are temporary.
 */
public class EntityQueryPool {
	
	private final Map<String, EntityQuery> entityQueries;
	
	public EntityQueryPool() {
		entityQueries = new HashMap<>();
	}
	
	/**
	 * Fetches a non-disposable entity query from the pool or creates a new one if it doesn't exist yet.
	 * @param componentTypes Component types of the query
	 */
	public EntityQuery getQuery(Class<? extends Component>... componentTypes) {
		return getQuery(componentTypes, false);
	}
	
	/**
	 * Creates a new entity query and doesn't add it to the pool.
	 * Systems that consume the query are allowed to dispose of its results.
	 * @param componentTypes Component types of the query
	 */
	public EntityQuery getDisposableQuery(Class<? extends Component>... componentTypes) {
		return getQuery(componentTypes, true);
	}
	
	/**
	 * Fetches an entity query from the pool or creates a new one if it doesn't exist yet.
	 * If <code>disposable</code> is set to <code>true</code>, a new query will always be created.
	 * Disposable queries are queries that are consumed by systems that might dispose the results of their query,
	 * which means the query cannot be reused by other systems.
	 * @param componentTypes Component types of the query
	 * @param disposable Indicates whether the system that will consume this query might dispose its results.
	 */
	public EntityQuery getQuery(Class<? extends Component>[] componentTypes, boolean disposable) {
		if (disposable) {
			return new EntityQuery(componentTypes);
		}
		
		String key = generateQueryKey(componentTypes);
		
		// Fetch existing query from pool
		if (entityQueries.containsKey(key)) {
			return entityQueries.get(key);
		}
		
		// Create new query and add to pool
		EntityQuery entityQuery = new EntityQuery(componentTypes);
		entityQueries.put(key, entityQuery);
		
		return entityQuery;
	}
	
	public void clear() {
		for (EntityQuery query : entityQueries.values()) {
			query.destroy();
		}
		entityQueries.clear();
	}
	
	/**
	 * Generates a unique string key based on an array of component types for an entity query.
	 * The key is generated by concatenating the names of the component types in alphabetical order, separated by colons ":".
	 * @param componentTypes Component types of the query
	 * @return String key
	 */
	private static String generateQueryKey(Class<? extends Component>[] componentTypes) {
		// Collect names of component types
		ArrayList<String> typeNames = new ArrayList<>();
		for (Class<?> componentType : componentTypes) {
			typeNames.add(componentType.getName());
		}
		// Sort component types to ensure the order is consistent
		Collections.sort(typeNames);

		return String.join(":", typeNames);
	}
}
